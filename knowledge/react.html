<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 面试题 | YoFoon&#39;s前端小站</title>
    <meta name="description" content="好好学习，努力化蛹成蝶">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/logo.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/logo.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="apple-mobile-web-app-status-bar-style">
    
    <link rel="preload" href="/assets/css/0.styles.05cc7eb5.css" as="style"><link rel="preload" href="/assets/js/app.1274b19c.js" as="script"><link rel="preload" href="/assets/js/3.e5f6c01d.js" as="script"><link rel="preload" href="/assets/js/67.2fdfc8d2.js" as="script"><link rel="preload" href="/assets/js/6.da654ace.js" as="script"><link rel="prefetch" href="/assets/js/10.92e21c8d.js"><link rel="prefetch" href="/assets/js/11.cc1411d8.js"><link rel="prefetch" href="/assets/js/12.2d961c16.js"><link rel="prefetch" href="/assets/js/13.205676dc.js"><link rel="prefetch" href="/assets/js/14.b165508a.js"><link rel="prefetch" href="/assets/js/15.486ed8f4.js"><link rel="prefetch" href="/assets/js/16.ac82d50a.js"><link rel="prefetch" href="/assets/js/17.db1abd0b.js"><link rel="prefetch" href="/assets/js/18.bd9497b5.js"><link rel="prefetch" href="/assets/js/19.081301d7.js"><link rel="prefetch" href="/assets/js/20.b8d7b737.js"><link rel="prefetch" href="/assets/js/21.086584d3.js"><link rel="prefetch" href="/assets/js/22.70d87ff4.js"><link rel="prefetch" href="/assets/js/23.cf08daab.js"><link rel="prefetch" href="/assets/js/24.07387fb5.js"><link rel="prefetch" href="/assets/js/25.4e770138.js"><link rel="prefetch" href="/assets/js/26.4bf8b93c.js"><link rel="prefetch" href="/assets/js/27.38076681.js"><link rel="prefetch" href="/assets/js/28.eddd4fec.js"><link rel="prefetch" href="/assets/js/29.10d1433e.js"><link rel="prefetch" href="/assets/js/30.4a707e0a.js"><link rel="prefetch" href="/assets/js/31.8677c398.js"><link rel="prefetch" href="/assets/js/32.12c7f3b9.js"><link rel="prefetch" href="/assets/js/33.932ee82b.js"><link rel="prefetch" href="/assets/js/34.d4b9aeb4.js"><link rel="prefetch" href="/assets/js/35.acc1896e.js"><link rel="prefetch" href="/assets/js/36.527e7284.js"><link rel="prefetch" href="/assets/js/37.a3f87927.js"><link rel="prefetch" href="/assets/js/38.88ddbf7a.js"><link rel="prefetch" href="/assets/js/39.fd7962a1.js"><link rel="prefetch" href="/assets/js/4.d584cd42.js"><link rel="prefetch" href="/assets/js/40.15dc2bae.js"><link rel="prefetch" href="/assets/js/41.92269fcd.js"><link rel="prefetch" href="/assets/js/42.b6a87d96.js"><link rel="prefetch" href="/assets/js/43.84bcdfb9.js"><link rel="prefetch" href="/assets/js/44.86791ad1.js"><link rel="prefetch" href="/assets/js/45.6a3fb16d.js"><link rel="prefetch" href="/assets/js/46.b5293326.js"><link rel="prefetch" href="/assets/js/47.7d80c117.js"><link rel="prefetch" href="/assets/js/48.5085aee1.js"><link rel="prefetch" href="/assets/js/49.45b201a6.js"><link rel="prefetch" href="/assets/js/5.e3a314f7.js"><link rel="prefetch" href="/assets/js/50.3ea3c47a.js"><link rel="prefetch" href="/assets/js/51.7319689a.js"><link rel="prefetch" href="/assets/js/52.c4d9b204.js"><link rel="prefetch" href="/assets/js/53.3114bf6b.js"><link rel="prefetch" href="/assets/js/54.995bca0e.js"><link rel="prefetch" href="/assets/js/55.e27397eb.js"><link rel="prefetch" href="/assets/js/56.e4513a4e.js"><link rel="prefetch" href="/assets/js/57.1159b507.js"><link rel="prefetch" href="/assets/js/58.7d58a545.js"><link rel="prefetch" href="/assets/js/59.dbd46eb1.js"><link rel="prefetch" href="/assets/js/60.92e88ec9.js"><link rel="prefetch" href="/assets/js/61.8d5cdca3.js"><link rel="prefetch" href="/assets/js/62.9af7431d.js"><link rel="prefetch" href="/assets/js/63.b41e9a05.js"><link rel="prefetch" href="/assets/js/64.4a3c4ea7.js"><link rel="prefetch" href="/assets/js/65.835613ef.js"><link rel="prefetch" href="/assets/js/66.8cd25ac9.js"><link rel="prefetch" href="/assets/js/68.1a6fa670.js"><link rel="prefetch" href="/assets/js/69.24c523fc.js"><link rel="prefetch" href="/assets/js/7.0f973c56.js"><link rel="prefetch" href="/assets/js/70.afc49943.js"><link rel="prefetch" href="/assets/js/71.425d9845.js"><link rel="prefetch" href="/assets/js/72.df82cb35.js"><link rel="prefetch" href="/assets/js/73.6461ff8b.js"><link rel="prefetch" href="/assets/js/74.42fdc9ca.js"><link rel="prefetch" href="/assets/js/75.6029d9dd.js"><link rel="prefetch" href="/assets/js/76.ac5c877d.js"><link rel="prefetch" href="/assets/js/77.91697145.js"><link rel="prefetch" href="/assets/js/78.3f23eaf7.js"><link rel="prefetch" href="/assets/js/79.3390703e.js"><link rel="prefetch" href="/assets/js/8.cd0d92c8.js"><link rel="prefetch" href="/assets/js/80.14cf59a6.js"><link rel="prefetch" href="/assets/js/81.df106301.js"><link rel="prefetch" href="/assets/js/82.b9c47d41.js"><link rel="prefetch" href="/assets/js/83.7d601b24.js"><link rel="prefetch" href="/assets/js/84.8f06dfd5.js"><link rel="prefetch" href="/assets/js/85.0361ac05.js"><link rel="prefetch" href="/assets/js/86.cfc2ea02.js"><link rel="prefetch" href="/assets/js/87.04b875f6.js"><link rel="prefetch" href="/assets/js/9.cd570fc8.js"><link rel="prefetch" href="/assets/js/vendors~notification.7bcb2342.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05cc7eb5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YoFoon's前端小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knowledge/" class="nav-link router-link-active">知识</a></div><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div> <a href="https://github.com/YoFoon/FE-FACE" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knowledge/" class="nav-link router-link-active">知识</a></div><div class="nav-item"><a href="/blog/" class="nav-link">博客</a></div> <a href="https://github.com/YoFoon/FE-FACE" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/" class="sidebar-link">知识点</a></li><li><a href="/knowledge/book.html" class="sidebar-link">书籍/课程推荐</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/html.html" class="sidebar-link">HTML 基础</a></li><li><a href="/knowledge/css.html" class="sidebar-link">CSS 基础</a></li><li><a href="/knowledge/jsBasic.html" class="sidebar-link">JavaScript 基础</a></li><li><a href="/knowledge/browser.html" class="sidebar-link">浏览器基础</a></li><li><a href="/knowledge/jsonp.html" class="sidebar-link">前端跨域</a></li><li><a href="/knowledge/jsWritten.html" class="sidebar-link">JS 手写源码</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端深入</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/hoisting.html" class="sidebar-link">JavaScript 的『预解释』与『变量提升』</a></li><li><a href="/knowledge/eventLoop.html" class="sidebar-link">Event Loop 详解</a></li><li><a href="/knowledge/immutable.html" class="sidebar-link">实现不可变数据</a></li><li><a href="/knowledge/memory.html" class="sidebar-link">JavaScript 内存管理</a></li><li><a href="/knowledge/deepclone.html" class="sidebar-link">实现深克隆</a></li><li><a href="/knowledge/event.html" class="sidebar-link">如何实现一个 Event</a></li><li><a href="/knowledge/mechanism.html" class="sidebar-link">JavaScript 的运行机制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/dom.html" class="sidebar-link">DOM</a></li><li><a href="/knowledge/domRender.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/knowledge/cache.html" class="sidebar-link">浏览器的缓存机制</a></li><li><a href="/knowledge/url.html" class="sidebar-link">输入 URL 到页面渲染的整个流程</a></li><li><a href="/knowledge/requestHeader.html" class="sidebar-link">常见请求头和响应头</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/http.html" class="sidebar-link">HTTP 协议</a></li><li><a href="/knowledge/tcp.html" class="sidebar-link">TCP 面试题</a></li><li><a href="/knowledge/cdn.html" class="sidebar-link">CDN 原理简析</a></li><li><a href="/knowledge/https.html" class="sidebar-link">HTTPS</a></li><li><a href="/knowledge/http2.html" class="sidebar-link">HTTP2</a></li><li><a href="/knowledge/httpWritten.html" class="sidebar-link">HTTP 笔试部分</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>常用算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/algorithm.html" class="sidebar-link">算法面试题</a></li><li><a href="/knowledge/string.html" class="sidebar-link">字符串类面试题</a></li><li><a href="/knowledge/tree.html" class="sidebar-link">二叉树</a></li><li><a href="/knowledge/chain.html" class="sidebar-link">链表</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/react.html" class="active sidebar-link">React 面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-最新的生命周期是怎样的" class="sidebar-link">React 最新的生命周期是怎样的?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-的请求应该放在哪个生命周期中" class="sidebar-link">React 的请求应该放在哪个生命周期中?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#setstate-到底是异步还是同步" class="sidebar-link">setState 到底是异步还是同步?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-组件通信如何实现" class="sidebar-link">React 组件通信如何实现?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-有哪些优化性能是手段" class="sidebar-link">React 有哪些优化性能是手段?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-如何进行组件-逻辑复用" class="sidebar-link">React 如何进行组件/逻辑复用?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-hooks-优点" class="sidebar-link">React Hooks 优点</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-hooks-缺陷" class="sidebar-link">React Hooks 缺陷</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#你是如何理解-fiber-的" class="sidebar-link">你是如何理解 fiber 的?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#你对-time-slice-的理解" class="sidebar-link">你对 Time Slice 的理解?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#redux-的工作流程" class="sidebar-link">redux 的工作流程?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react-redux-是如何工作的" class="sidebar-link">react-redux 是如何工作的?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#react合成事件和dom原生事件" class="sidebar-link">React合成事件和DOM原生事件</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#redux-与-mobx-的区别" class="sidebar-link">redux 与 mobx 的区别?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#redux-中如何进行异步操作" class="sidebar-link">redux 中如何进行异步操作?</a></li><li class="sidebar-sub-header"><a href="/knowledge/react.html#redux-异步中间件之间的优劣" class="sidebar-link">redux 异步中间件之间的优劣?</a></li></ul></li><li><a href="/knowledge/virtualDom.html" class="sidebar-link">虚拟 DOM 原理</a></li><li><a href="/knowledge/devsProxy.html" class="sidebar-link">Proxy 比 defineproperty 优劣对比?</a></li><li><a href="/knowledge/setState.html" class="sidebar-link">setState 到底是异步的还是同步的?</a></li><li><a href="/knowledge/router.html" class="sidebar-link">前端路由的实现</a></li><li><a href="/knowledge/reactError.html" class="sidebar-link">React 错误捕获</a></li><li><a href="/knowledge/fiber.html" class="sidebar-link">React Fiber 架构解析</a></li><li><a href="/knowledge/abstract.html" class="sidebar-link">React 组件复用指南</a></li><li><a href="/knowledge/reactHook.html" class="sidebar-link">React-hooks 抽象组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>性能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/load.html" class="sidebar-link">前端性能优化</a></li><li><a href="/knowledge/execute.html" class="sidebar-link">前端性能优化-执行篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/webpack.html" class="sidebar-link">webpack 面试题</a></li><li><a href="/knowledge/engineering.html" class="sidebar-link">前端工程化</a></li><li><a href="/knowledge/ast.html" class="sidebar-link">如何写一个 babel</a></li><li><a href="/knowledge/WebpackHMR.html" class="sidebar-link">Webpack HMR 原理解析</a></li><li><a href="/knowledge/webpackPlugin.html" class="sidebar-link">webpack 插件编写</a></li><li><a href="/knowledge/webpackPluginDesign.html" class="sidebar-link">webpack 插件化设计</a></li><li><a href="/knowledge/webpackMoudle.html" class="sidebar-link">Webpack 模块机制</a></li><li><a href="/knowledge/webpackLoader.html" class="sidebar-link">webpack loader 实现</a></li><li><a href="/knowledge/babelPlugin.html" class="sidebar-link">如何开发 Babel 插件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/security.html" class="sidebar-link">前端安全</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-面试题"><a href="#react-面试题" aria-hidden="true" class="header-anchor">#</a> React 面试题</h1> <h2 id="react-最新的生命周期是怎样的"><a href="#react-最新的生命周期是怎样的" aria-hidden="true" class="header-anchor">#</a> React 最新的生命周期是怎样的?</h2> <p>React 16 之后有三个生命周期被废弃(但并未删除)</p> <ul><li>componentWillMount</li> <li>componentWillReceiveProps</li> <li>componentWillUpdate</li></ul> <p>官方计划在 17 版本完全删除这三个函数，只保留 UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们</p> <p>挂载阶段:</p> <ul><li>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化 state 对象或者给自定义方法绑定 this</li> <li>getDerivedStateFromProps: <code>static getDerivedStateFromProps(nextProps, prevState)</code>,这是个静态方法,当我们接收到新的属性想去修改我们 state，可以使用 getDerivedStateFromProps</li> <li>render: render 函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</li> <li>componentDidMount: 组件装载之后调用，此时我们可以获取到 DOM 节点并操作，比如对 canvas，svg 的操作，服务器请求，订阅都可以写在这个里面，但是记得在 componentWillUnmount 中取消订阅</li></ul> <p>更新阶段:</p> <ul><li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li> <li>shouldComponentUpdate: <code>shouldComponentUpdate(nextProps, nextState)</code>,有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能</li> <li>render: 更新阶段也会触发此生命周期</li> <li>getSnapshotBeforeUpdate: <code>getSnapshotBeforeUpdate(prevProps, prevState)</code>,这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此生命周期必须与 componentDidUpdate 搭配使用</li> <li>componentDidUpdate: <code>componentDidUpdate(prevProps, prevState, snapshot)</code>,该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</li></ul> <p>卸载阶段:</p> <ul><li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作</li></ul> <p><img src="https://qnm.hunliji.com/Fh3PiwrPfl5Jk1GksHi91gMQRrpN" alt="生命周期"></p> <blockquote><p>一个查看 react 生命周期的<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="react-的请求应该放在哪个生命周期中"><a href="#react-的请求应该放在哪个生命周期中" aria-hidden="true" class="header-anchor">#</a> React 的请求应该放在哪个生命周期中?</h2> <p>不要在 <code>componentWillMount</code> 中添加事件监听</p> <p><code>componentWillMount</code> 可以被打断或调用多次，因此无法保证事件监听能在 unmount 的时候被成功卸载，可能会引起内存泄露</p> <p>由于 React 未来的版本中推出了异步渲染，在 <code>dom</code> 被挂载之前的阶段都可以被打断重来，导致 <code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code> 在一次更新中可能会被触发多次，因此那些只希望触发一次的副作用应该放在 <code>componentDidMount</code> 中</p> <p>这也就是为什么要把异步请求放在 <code>componentDidMount</code> 中，而不是放在 <code>componentWillMount</code> 中的原因，为了向后兼容</p> <p>目前官方推荐的异步请求是在<code>componentDidmount</code>中进行.</p> <p>如果有特殊需求需要提前请求,也可以在特殊情况下在<code>constructor</code>中请求</p> <blockquote><p>react 17 之后<code>componentWillMount</code>会被废弃,仅仅保留<code>UNSAFE_componentWillMount</code></p></blockquote> <h2 id="setstate-到底是异步还是同步"><a href="#setstate-到底是异步还是同步" aria-hidden="true" class="header-anchor">#</a> setState 到底是异步还是同步?</h2> <p>先给出答案: 有时表现出异步,有时表现出同步</p> <ol><li><code>setState</code>只在合成事件(setState)和钩子函数(生命周期)中是“异步”的，在原生事件(addEventListener)和setTimeout中都是同步的。</li> <li><code>setState</code>  的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数  <code>setState(partialState, callback)</code>  中的<code>callback</code>拿到更新后的结果。</li> <li><code>setState</code>  的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</li></ol> <h2 id="react-组件通信如何实现"><a href="#react-组件通信如何实现" aria-hidden="true" class="header-anchor">#</a> React 组件通信如何实现?</h2> <p>React 组件间通信方式:</p> <ul><li>父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯</li> <li>子组件向父组件通讯: props+回调的方式,父组件向子组件传递 props 进行通讯，此 props 为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</li> <li>兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</li> <li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言, 对于跨越多层的全局数据通过<code>Context</code>通信再适合不过</li> <li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入 event 模块进行通信<a href="https://juejin.im/post/5d44e3745188255d5861d654" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>全局状态管理工具: 借助 Redux 或者 Mobx 等全局状态管理工具进行通信,这种工具会维护一个全局状态中心 Store,并根据不同的事件产生新的状态</li></ul> <h2 id="react-有哪些优化性能是手段"><a href="#react-有哪些优化性能是手段" aria-hidden="true" class="header-anchor">#</a> React 有哪些优化性能是手段?</h2> <p>性能优化的手段很多时候是通用的详情见<a href="/knowledge/load.html">前端性能优化加载篇</a></p> <h2 id="react-如何进行组件-逻辑复用"><a href="#react-如何进行组件-逻辑复用" aria-hidden="true" class="header-anchor">#</a> React 如何进行组件/逻辑复用?</h2> <p>抛开已经被官方弃用的 Mixin,组件抽象的技术目前有三种比较主流:</p> <ul><li>高阶组件:
<ul><li>属性代理</li> <li>反向继承</li></ul></li> <li>渲染属性</li> <li>react-hooks</li></ul> <p>组件复用详解见<a href="/knowledge/abstract.html">组件复用</a></p> <h2 id="react-hooks-优点"><a href="#react-hooks-优点" aria-hidden="true" class="header-anchor">#</a> React Hooks 优点</h2> <ul><li>简洁: React Hooks 解决了 HOC 和 Render Props 的嵌套问题,更加简洁</li> <li>解耦: React Hooks 可以更方便地把 UI 和状态分离,做到更彻底的解耦</li> <li>组合: Hooks 中可以引用另外的 Hooks 形成新的 Hooks,组合变化万千</li> <li>函数友好: React Hooks 为函数组件而生,从而解决了类组件的几大问题:
<ul><li>this 指向容易错误</li> <li>分割在不同声明周期中的逻辑使得代码难以理解和维护</li> <li>代码复用成本高（高阶组件容易使代码量剧增）</li></ul></li></ul> <h2 id="react-hooks-缺陷"><a href="#react-hooks-缺陷" aria-hidden="true" class="header-anchor">#</a> React Hooks 缺陷</h2> <ul><li><p>额外的学习成本（Functional Component 与 Class Component 之间的困惑）</p></li> <li><p>写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本</p></li> <li><p>破坏了 PureComponent、React.memo 浅比较的性能优化效果（为了取最新的 props 和 state，每次 render()都要重新创建事件处函数）</p></li> <li><p>在闭包场景可能会引用到旧的 state、props 值</p></li> <li><p>内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）</p></li> <li><p>React.memo 并不能完全替代 shouldComponentUpdate（因为拿不到 state change，只针对 props change）</p></li></ul> <blockquote><p>关于 react-hooks 的评价来源于官方<a href="https://github.com/reactjs/rfcs/blob/master/text/0068-react-hooks.md#drawbacks" target="_blank" rel="noopener noreferrer">react-hooks RFC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="你是如何理解-fiber-的"><a href="#你是如何理解-fiber-的" aria-hidden="true" class="header-anchor">#</a> 你是如何理解 fiber 的?</h2> <p>React Fiber 是一种基于浏览器的<strong>单线程调度算法</strong>.</p> <p>React 16 之前 ，<code>reconcilation</code>  算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.</p> <p><code>Fiber</code>：一种将 <code>recocilation</code> （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</p> <h2 id="你对-time-slice-的理解"><a href="#你对-time-slice-的理解" aria-hidden="true" class="header-anchor">#</a> 你对 Time Slice 的理解?</h2> <p><strong>时间分片</strong></p> <ul><li>React 在渲染（render）的时候，不会阻塞现在的线程</li> <li>如果你的设备足够快，你会感觉渲染是同步的</li> <li>如果你设备非常慢，你会感觉还算是灵敏的</li> <li>虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来</li> <li>同样书写组件的方式</li></ul> <p>也就是说，这是 React 背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？</p> <p><img src="https://qnm.hunliji.com/Fr-h5um6oxUGYLZQm8_C8qXdhDja" alt="">
有图表三个图表，有一个输入框，以及上面的三种模式<br><strong>这个组件非常的巨大，而且在输入框</strong>每次**输入东西的时候，就会进去一直在渲染。**为了更好的看到渲染的性能，Dan 为我们做了一个表。</p> <p>我们先看看，同步模式：
<img src="https://qnm.hunliji.com/FsQ2X_Voxm_swy9TbYg9ga1HTVxN" alt=""></p> <p>同步模式下，我们都知道，我们没输入一个字符，React 就开始渲染，当 React 渲染一颗巨大的树的时候，是非常卡的，所以才会有 shouldUpdate 的出现，在这里 Dan 也展示了，这种卡！</p> <p>我们再来看看第二种（Debounced 模式）：
<img src="https://qnm.hunliji.com/FuYu434XPDd1bZMWn1Gcvei4Z1sR" alt=""></p> <p>Debounced 模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变化。<br>这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。</p> <p>切换到异步模式：
<img src="https://qnm.hunliji.com/Fifu0QfOFkklJJnzFMqkgDvgqeGq" alt=""></p> <p>异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色的。</p> <p>时间分片正是基于可随时打断、重启的 Fiber 架构,可打断当前任务,优先处理紧急且重要的任务,保证页面的流畅运行.</p> <h2 id="redux-的工作流程"><a href="#redux-的工作流程" aria-hidden="true" class="header-anchor">#</a> redux 的工作流程?</h2> <p>首先，我们看下几个核心概念：</p> <ul><li>Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个 Store。</li> <li>State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。</li> <li>Action：State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li> <li>Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator。</li> <li>Reducer：Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</li> <li>dispatch：是 View 发出 Action 的唯一方法。</li></ul> <p>然后我们过下整个工作流程：</p> <ol><li>首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法。</li> <li>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</li> <li>State 一旦有变化，Store 就会调用监听函数，来更新 View。</li></ol> <p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/0ab0e624522ae6efef415b53cb923bf7.png" alt="2019-08-01-17-29-20"></p> <h2 id="react-redux-是如何工作的"><a href="#react-redux-是如何工作的" aria-hidden="true" class="header-anchor">#</a> react-redux 是如何工作的?</h2> <ul><li>Provider: Provider 的作用是从最外部封装了整个应用，并向 connect 模块传递 store</li> <li>connect: 负责连接 React 和 Redux
<ul><li>获取 state: connect 通过 context 获取 Provider 中的 store，通过 store.getState()获取整个 store tree 上所有 state</li> <li>包装原组件: 将 state 和 action 通过 props 的方式传入到原组件内部 wrapWithConnect 返回一个 ReactComponent 对象 Connect，Connect 重新 render 外部传入的原组件 WrappedComponent，并把 connect 中传入的 mapStateToProps, mapDispatchToProps 与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent</li> <li>监听 store tree 变化: connect 缓存了 store tree 中 state 的状态,通过当前 state 状态和变更前 state 状态进行比较,从而确定是否调用<code>this.setState()</code>方法触发 Connect 及其子组件的重新渲染</li></ul></li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/710f0a9f0a8e6a320f55fa0ca795a3c7.png" alt="2019-08-01-22-21-51"></p> <h2 id="react合成事件和dom原生事件"><a href="#react合成事件和dom原生事件" aria-hidden="true" class="header-anchor">#</a> React合成事件和DOM原生事件</h2> <h3 id="先说一下结论"><a href="#先说一下结论" aria-hidden="true" class="header-anchor">#</a> 先说一下结论</h3> <ul><li>合成事件的监听器是统一注册在document上的，且仅有冒泡阶段。<strong>所以原生事件的监听器响应总是比合成事件的监听器早</strong></li> <li>阻止原生事件的冒泡后，会阻止合成事件的监听器执行</li></ul> <h3 id="响应顺序"><a href="#响应顺序" aria-hidden="true" class="header-anchor">#</a> 响应顺序</h3> <div class="language- extra-class"><pre class="language-text"><code>class Demo extends Component {
  componentDidMount() {
      const $this = ReactDOM.findDOMNode(this)
      $this.addEventListener('click', this.onDOMClick, false)
  }
  onDOMClick = evt =&gt; { console.log('dom event') }
  onClick = evt =&gt; { console.log('react event') }
  render() {
      return &lt;div onClick={this.onClick}&gt;Demo&lt;/div&gt;
  }
}
</code></pre></div><p>最终控制台输出为：</p> <blockquote><p>dom event    react event</p></blockquote> <h3 id="阻止冒泡"><a href="#阻止冒泡" aria-hidden="true" class="header-anchor">#</a> 阻止冒泡</h3> <p>如果在onDOMClick中调用evt.stopPropagation()呢？</p> <p>由于DOM事件被阻止冒泡了，无法到达document，所以合成事件自然不会被触发，控制台输出就变成了：</p> <blockquote><p>dom event</p></blockquote> <h2 id="redux-与-mobx-的区别"><a href="#redux-与-mobx-的区别" aria-hidden="true" class="header-anchor">#</a> redux 与 mobx 的区别?</h2> <p><strong>两者对比:</strong></p> <ul><li>redux 将数据保存在单一的 store 中，mobx 将数据保存在分散的多个 store 中</li> <li>redux 使用 plain object 保存数据，需要手动处理变化后的操作；mobx 适用 observable 保存数据，数据变化后自动处理响应的操作</li> <li>redux 使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx 中的状态是可变的，可以直接对其进行修改</li> <li>mobx 相对来说比较简单，在其中有很多的抽象，mobx 更多的使用面向对象的编程思维；redux 会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li> <li>mobx 中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而 redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li></ul> <p><strong>场景辨析:</strong></p> <p>基于以上区别,我们可以简单得分析一下两者的不同使用场景.</p> <p>mobx 更适合数据不复杂的应用: mobx 难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.</p> <p>redux 适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于 redux 不可变的特性，天然支持这些操作.</p> <p>mobx 适合短平快的项目: mobx 上手简单,样板代码少,可以很大程度上提高开发效率.</p> <p>当然 mobx 和 redux 也并不一定是非此即彼的关系,你也可以在项目中用 redux 作为全局状态管理,用 mobx 作为组件局部状态管理器来用.</p> <h2 id="redux-中如何进行异步操作"><a href="#redux-中如何进行异步操作" aria-hidden="true" class="header-anchor">#</a> redux 中如何进行异步操作?</h2> <p>当然,我们可以在<code>componentDidmount</code>中直接进行请求无须借助 redux.</p> <p>但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助 redux 的异步中间件进行异步处理.</p> <p>redux 异步流中间件其实有很多,但是当下主流的异步中间件只有两种 redux-thunk、redux-saga，当然 redux-observable 可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度还是 npm 下载量都比较差了.</p> <h2 id="redux-异步中间件之间的优劣"><a href="#redux-异步中间件之间的优劣" aria-hidden="true" class="header-anchor">#</a> redux 异步中间件之间的优劣?</h2> <p><strong>redux-thunk 优点:</strong></p> <ul><li>体积小: redux-thunk 的实现方式很简单,只有不到 20 行代码</li> <li>使用简单: redux-thunk 没有引入像 redux-saga 或者 redux-observable 额外的范式,上手简单</li></ul> <p><strong>redux-thunk 缺陷:</strong></p> <ul><li>样板代码过多: 与 redux 本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</li> <li>耦合严重: 异步操作与 redux 的 action 偶合在一起,不方便管理</li> <li>功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</li></ul> <p><strong>redux-saga 优点:</strong></p> <ul><li>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</li> <li>action 摆脱 thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</li> <li>异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理</li> <li>功能强大: redux-saga 提供了大量的 Saga 辅助函数和 Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</li> <li>灵活: redux-saga 可以将多个 Saga 可以串行/并行组合起来,形成一个非常实用的异步 flow</li> <li>易测试，提供了各种 case 的测试方案，包括 mock task，分支覆盖等等</li></ul> <p><strong>redux-saga 缺陷:</strong></p> <ul><li>额外的学习成本: redux-saga 不仅在使用难以理解的 generator function,而且有数十个 API,学习成本远超 redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与 redux-observable 不同,redux-observable 虽然也有额外学习成本但是背后是 rxjs 和一整套思想</li> <li>体积庞大: 体积略大,代码近 2000 行，min 版 25KB 左右</li> <li>功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</li> <li>ts 支持不友好: yield 无法返回 TS 类型</li></ul> <p><strong>redux-observable 优点:</strong></p> <ul><li>功能最强: 由于背靠 rxjs 这个强大的响应式编程的库,借助 rxjs 的操作符,你可以几乎做任何你能想到的异步处理</li> <li>背靠 rxjs: 由于有 rxjs 的加持,如果你已经学习了 rxjs,redux-observable 的学习成本并不高,而且随着 rxjs 的升级 redux-observable 也会变得更强大</li></ul> <p><strong>redux-observable 缺陷:</strong></p> <ul><li>学习成本奇高: 如果你不会 rxjs,则需要额外学习两个复杂的库</li> <li>社区一般: redux-observable 的下载量只有 redux-saga 的 1/5,社区也不够活跃,在复杂异步流中间件这个层面 redux-saga 仍处于领导地位</li></ul> <blockquote><p>关于 redux-saga 与 redux-observable 的详细比较可见<a href="https://hackmd.io/@2qVnJRlJRHCk20dvVxsySA/H1xLHUQ8e?type=view#side-by-side-**comparison**" target="_blank" rel="noopener noreferrer">此链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/YoFoon/FE-FACE/edit/master/knowledge/react.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/knowledge/chain.html" class="prev">
          链表
        </a></span> <span class="next"><a href="/knowledge/virtualDom.html">
          虚拟 DOM 原理
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.1274b19c.js" defer></script><script src="/assets/js/3.e5f6c01d.js" defer></script><script src="/assets/js/67.2fdfc8d2.js" defer></script><script src="/assets/js/6.da654ace.js" defer></script>
  </body>
</html>
