(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{217:function(e,t,n){"use strict";n.r(t);var o=n(4),r=Object(o.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"调度入口函数-schedulework"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调度入口函数-schedulework","aria-hidden":"true"}},[e._v("#")]),e._v(" 调度入口函数 scheduleWork")]),e._v(" "),n("p",[n("code",[e._v("ReactDOM.render")]),e._v(", "),n("code",[e._v("setState")]),e._v(", "),n("code",[e._v("forceUpdate")]),e._v(", "),n("code",[e._v("React Hooks")]),e._v("最终都要经过"),n("code",[e._v("scheduleWork")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {\n  const root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    return;\n  }\n\n  if (\n    !isWorking &&\n    nextRenderExpirationTime !== NoWork &&\n    expirationTime < nextRenderExpirationTime\n  ) {\n    // This is an interruption. (Used for performance tracking.)\n    interruptedBy = fiber;\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n    // If we're in the render phase, we don't need to schedule this root\n    // for an update, because we'll do it before we exit...\n    !isWorking ||\n    isCommitting ||\n    // ...unless this is a different root than the one we're rendering.\n    nextRoot !== root\n  ) {\n    const rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n  }\n}\n")])])]),n("p",[e._v("进入"),n("code",[e._v("scheduleWork")]),e._v("的第一个方法"),n("code",[e._v("scheduleWorkToRoot")]),e._v(",负责将当前"),n("code",[e._v("fiber")]),e._v("及其"),n("code",[e._v("alternate")]),e._v("的过期时间推迟（或者叫加大）。由于在"),n("code",[e._v("ReactFiber")]),e._v("中，过期时间等价于优先级，换言之，一个组件在某个时间段"),n("code",[e._v("setState")]),e._v("频繁，那么它就越优先更新。")]),e._v(" "),n("p",[e._v("在并发模式下，"),n("code",[e._v("setState")]),e._v("后"),n("strong",[e._v("33ms")]),e._v("执行（如果在动画中，为了保证流畅，增长到 100ms 间隔 ）。如果更新的节点是一个受控组件（input），那么它是直接进入"),n("code",[e._v("interactiveUpdates")]),e._v("方法，不经过 scheduleWork，是"),n("strong",[e._v("立即更新")]),e._v("！React 还有一个没登记到文档 batchedUpdates 方法，它可以让一大遍节点立即更新，并且无视 shouldComponentUpdate return false！")])])},[],!1,null,null,null);t.default=r.exports}}]);