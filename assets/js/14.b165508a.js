(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{212:function(e,n,t){"use strict";t.r(n);var r=t(4),i=Object(r.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"expirationtime-计算规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime-计算规则","aria-hidden":"true"}},[e._v("#")]),e._v(" ExpirationTime 计算规则")]),e._v(" "),t("p",[e._v("react 主要把到期时间分为两种：异步任务到期时间与交互工作的到期时间。react 的到期时间与系统的时间 ms"),t("strong",[e._v("不是 1:1")]),e._v("的关系，低优先级异步任务的两个时间间隔相差不到 250ms(相当于 25 单位的 "),t("strong",[e._v("到期时间")]),e._v(")的任务会被设置为同一个到期时间，交互异步任务间隔 100ms(相当于 10 个单位的 "),t("strong",[e._v("到期时间")]),e._v(")，因此减少了一些不必要的组件渲染，并且保证交互可以及时响应。")]),e._v(" "),t("h4",{attrs:{id:"expirationtime-的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime-的作用","aria-hidden":"true"}},[e._v("#")]),e._v(" ExpirationTime 的作用")]),e._v(" "),t("p",[e._v("在 react 中，为了防止某个"),t("code",[e._v("update")]),e._v("因为优先级的原因一直被打断而不能执行。react 会设置一个"),t("code",[e._v("ExpirationTime")]),e._v("，当时间到了"),t("code",[e._v("ExpirationTime")]),e._v("这个值的时候，如果某个"),t("code",[e._v("update")]),e._v("还未执行的时候，react 将会强行执行该"),t("code",[e._v("update")]),e._v("，这就是"),t("code",[e._v("ExpirationTime")]),e._v("的作用")]),e._v(" "),t("h4",{attrs:{id:"expirationtime-的权重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime-的权重","aria-hidden":"true"}},[e._v("#")]),e._v(" expirationTime 的权重")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export const NoWork = 0; // 没有任务等待处理\nexport const Sync = 1; // 同步模式，立即处理任务\nexport const Never = 2147483647; // 表用不执行，优先级最低,Max int32: Math.pow(2, 31) - 1\n")])])]),t("p",[e._v("在第三节 ReactDom.render 中，曾提到了"),t("code",[e._v("updateContainer")]),e._v("这个函数（该函数位于"),t("code",[e._v("ReactFiberReconciler.js")]),e._v("这个文件中）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function updateContainer(\n  element: ReactNodeList, // 子组件，就是React.Dom中传入的组件\n  container: OpaqueRoot, // FiberRoot, 顶级root节点\n  parentComponent: ?React$Component<any, any>, // null\n  callback: ?Function, // callback\n): ExpirationTime {\n\t...\n\n  // currentTime是用来计算expirationTime\n  const currentTime = requestCurrentTime();\n\n  // expirationTime代表着优先级，expirationTime越小，优先级越高\n  // 同步模式下该值为 1， 每个层级的任务都是以链表的形式存在\n  // expirationTime 顾名思义就是这次更新的 超时时间, 留在后续分析\n  const expirationTime = computeExpirationForFiber(currentTime, current);\n\t...\n}\n")])])]),t("h5",{attrs:{id:"获取当前时间-currenttime-requestcurrenttime"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取当前时间-currenttime-requestcurrenttime","aria-hidden":"true"}},[e._v("#")]),e._v(" 获取当前时间 currentTime: requestCurrentTime")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function requestCurrentTime() {\n  if (isRendering) {\n    return currentSchedulerTime;\n  }\n  findHighestPriorityRoot();\n  if (\n    nextFlushedExpirationTime === NoWork ||\n    nextFlushedExpirationTime === Never\n  ) {\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  return currentSchedulerTime;\n}\n")])])]),t("p",[e._v("在 react 中，我们计"),t("code",[e._v("expirationTime")]),e._v("需要基于当前得到的时钟时间，在初始化时，取值用"),t("code",[e._v("Date.now()")]),e._v("或者"),t("code",[e._v("performance.now()")]),e._v("，react 用"),t("code",[e._v("currentRendererTime")]),e._v("这个便来来记录了这个值，用于一些不需要重新计算的场景。")]),e._v(" "),t("p",[e._v("我们找到"),t("code",[e._v("currentRendererTime")]),e._v("这个定义")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let originalStartTimeMs: number = now();\nlet currentRendererTime: ExpirationTime = msToExpirationTime(\n  originalStartTimeMs,\n);\nlet currentSchedulerTime: ExpirationTime = currentRendererTime;\n")])])]),t("p",[e._v("先获取到当前时间赋值给"),t("code",[e._v("currentRendererTime")]),e._v("，然后"),t("code",[e._v("currentRendererTime")]),e._v("赋值给"),t("code",[e._v("currentSchedulerTime")])]),e._v(" "),t("p",[e._v("解读一下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (isRendering) {\n\treturn currentSchedulerTime;\n}\n")])])]),t("p",[t("code",[e._v("isRrendering")]),e._v("在"),t("code",[e._v("performWorkOnRoot")]),e._v("的开始设置为 ture，在结束的时候设置为 false，都是同步的，"),t("code",[e._v("performWorkOnRoot")]),e._v("的先进入渲染阶段然后进入提交阶段，所以马上返回"),t("code",[e._v("currentSchedulerTime")])]),e._v(" "),t("p",[e._v("那么什么情况下会在这里出现新的"),t("code",[e._v("requestCurrentTime")]),e._v("呢？")]),e._v(" "),t("ul",[t("li",[e._v("在生命周期方法中调用了"),t("code",[e._v("setState")])]),e._v(" "),t("li",[e._v("需要挂起任务的时候")])]),e._v(" "),t("p",[e._v("也就是说 React 要求"),t("strong",[e._v("在一次 rendering 过程中，新产生的 update 用于计算过期时间的 current 必须跟目前的 renderTime 保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！")])]),e._v(" "),t("p",[e._v("在一个事件回调函数中调用多次"),t("code",[e._v("setState")]),e._v("的时候，"),t("code",[e._v("isRendering")]),e._v("总是"),t("code",[e._v("false")]),e._v("，如果是在生命周期钩子函数"),t("code",[e._v("componentDidMount")]),e._v("中调用 setState 的时候，"),t("code",[e._v("isRendering")]),e._v("为"),t("code",[e._v("true")]),e._v("，因为该钩子触发的时机就是在"),t("code",[e._v("performWorkOnRoot")]),e._v("中。")]),e._v(" "),t("p",[e._v("再看"),t("code",[e._v("findHighestPriorityRoot")])]),e._v(" "),t("p",[t("code",[e._v("findHighestPriorityRoot")]),e._v("会找到 root 双向链表（React.render 会创建一个 root 并添加到这个双向链表中）中有任务需要执行并且到期时间最大即优先级最高的任务，然后将这个需要更新的 root 以及最大到期时间赋值给"),t("code",[e._v("nextFlushedRoot")]),e._v("以及"),t("code",[e._v("nextFlushedExpirationTime")]),e._v("。当没有任务的时候"),t("code",[e._v("nextFlushedExpirationTime")]),e._v("为"),t("code",[e._v("NoWork")]),e._v("。")]),e._v(" "),t("p",[e._v("接着看第二个判断")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (\n    nextFlushedExpirationTime === NoWork || // 没有任务需要执行\n    nextFlushedExpirationTime === Never // Never代表用不执行\n  ) {\n  \t// 重新计算当前时间，并返回\n  \t// 注意：\n  \t// 这里调用的recomputeCurrentRendererTime是通过调用performance.now()或者Date.now()获取的时间。\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n")])])]),t("h4",{attrs:{id:"计算到期时间-computeexpirationforfiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算到期时间-computeexpirationforfiber","aria-hidden":"true"}},[e._v("#")]),e._v(" 计算到期时间:computeExpirationForFiber")]),e._v(" "),t("p",[e._v("作用：返回低优先级(普通异步更新)的"),t("code",[e._v("expirationTime")]),e._v("（过期时间）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 根据不同的阶段设置fiber任务的优先级\nfunction computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) {\n  let expirationTime;\n\n  // 如果 context 有更新任务需要执行\n  if (expirationContext !== NoWork) {\n  \t// expirationTime 设置为 context 上的到期时间\n    expirationTime = expirationContext;\n  // 如果处于 renderRoot 渲染阶段或者 commitRoot 提交阶段\n  } else if (isWorking) {\n    // 如果处于 commitRoot\n    if (isCommitting) {\n      // expirationTime 设置为同步 Sync, 设置为同步优先级即优先级最高\n      expirationTime = Sync;\n    // 否则（处于renderRoot）\n    } else {\n      // expirationTime 设置为当前的到期时间 nextRenderExpirationTime\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // fiber任务没有到期则重新计算expiration\n    // 异步模式\n    if (fiber.mode & ConcurrentMode) {\n    \t// 是否正在批量更新\n      if (isBatchingInteractiveUpdates) {\n        // 利用computeInteractiveExpiration计算expirationTime\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // 利用computeAsyncExpiration计算expirationTime\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // 有下一root树需要更新，并且到期时间与该树到期时间相等\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n      \t// expirationTime加一，表示让下一个root先更新\n        expirationTime += 1;\n      }\n    } else {\n      // 同步模式\n      expirationTime = Sync;\n    }\n  }\n  // 如果正在批处理交互式更新\n  if (isBatchingInteractiveUpdates) {\n  \t// 如果最低优先级的交互式更新优先级大于到期时间expirationTime或者没有交互式更新任务\n    if (expirationTime > lowestPriorityPendingInteractiveExpirationTime) {\n    \t// 将最低优先级的交互式更新任务到期时间设置为到期时间expirationTime\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n")])])]),t("p",[e._v("####expiration 算法实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("mport MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';\n\nexport type ExpirationTime = number;\n\nexport const NoWork = 0; // 没有任务等待处理\nexport const Sync = 1; // 同步模式，立即处理任务\nexport const Never = MAX_SIGNED_31_BIT_INT;\n\n// 过期时间单元, ms 分片\nconst UNIT_SIZE = 10;\n// 异步任务优先级上限, 到期时间偏移量\nconst MAGIC_NUMBER_OFFSET = 2;\n\n// 以ExpirationTime特定单位（1单位=10ms）表示的到期执行时间\n// 除以10 取整应该是要抹平 10 毫秒内的误差\n// 当然最终要用来计算时间差的时候会调用 expirationTimeToMs 恢复回去\n// 但是被取整去掉的 10 毫秒误差肯定是回不去的。\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\n// 以毫秒表示的到期执行时间\n// 将ExpirationTime特定单位时间转成时钟时间\nexport function expirationTimeToMs(expirationTime: ExpirationTime): number {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\n// 向上取整（整数单位到期执行时间）\n// 返回距离num最近的precision的倍数\nfunction ceiling(num: number, precision: number): number {\n\t// // ceiling(1010, 20) return: 1020\n  // ceiling(90, 20) return 100\n  return (((num / precision) | 0) + 1) * precision;\n}\n\n// 计算处理误差时间在内的到期时间\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\n\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\nexport function computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n")])])]),t("p",[t("code",[e._v("computeInteractiveExpiration")]),e._v(" 和 "),t("code",[e._v("computeAsyncExpiration")]),e._v("最终调用的都是"),t("code",[e._v("computeExpirationBucket")]),e._v("，所不同的只是后两个参数。并且"),t("strong",[e._v("interative 的优先级是高于 Async 的")])]),e._v(" "),t("p",[e._v("在整个计算公式中只有"),t("code",[e._v("currentTime")]),e._v("是变量，也就是当前的时间戳。我们拿"),t("code",[e._v("computeAsyncExpiration")]),e._v("举例，在"),t("code",[e._v("computeExpirationBucket")]),e._v("中接收的就是"),t("code",[e._v("currentTime")]),e._v("、"),t("code",[e._v("5000")]),e._v("和"),t("code",[e._v("250")])]),e._v(" "),t("p",[e._v("最终的公式就是："),t("code",[e._v("((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25")])]),e._v(" "),t("p",[e._v("翻译一下就是："),t("strong",[e._v("当前时间加上 498 然后处以 25 取整再加 1 再乘以 5，需要注意的是这里的 currentTime 是经过 msToExpirationTime 处理的，也就是((now / 10) | 0) + 2")])]),e._v(" "),t("p",[e._v("也就是说，"),t("code",[e._v("React")]),e._v("低优先级"),t("code",[e._v("update")]),e._v("的"),t("code",[e._v("expirationTime")]),e._v("间隔是"),t("code",[e._v("25ms")]),e._v("，\n"),t("code",[e._v("React")]),e._v("让两个相近（"),t("code",[e._v("25ms")]),e._v("内）的"),t("code",[e._v("update")]),e._v("得到相同的"),t("code",[e._v("expirationTime")]),e._v("，目的就是让这两个"),t("code",[e._v("update")]),e._v("自动合并成一个"),t("code",[e._v("Update")]),e._v("，从而达到批量更新的目的，就像"),t("code",[e._v("LOW_PRIORITY_BATCH_SIZE")]),e._v("的名字一样，自动合并批量更新。")]),e._v(" "),t("p",[e._v("同理，高优先级的过期时间间隔是"),t("code",[e._v("10ms")])])])},[],!1,null,null,null);n.default=i.exports}}]);