(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{216:function(e,n,t){"use strict";t.r(n);var i=t(4),r=Object(i.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"react中的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react中的数据结构","aria-hidden":"true"}},[e._v("#")]),e._v(" React中的数据结构")]),e._v(" "),t("h3",{attrs:{id:"fiberroot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fiberroot","aria-hidden":"true"}},[e._v("#")]),e._v(" FiberRoot")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{|\n  // 页面上挂载的dom节点, 就是render方法接收的第二个参数\n  containerInfo: any,\n  // 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到\n  pendingChildren: any,\n  // 当前树的根节点，就是FiberRoot\n  current: Fiber,\n\n  // 以下的优先级是用来区分\n  // 1、没有提交（committed）的任务\n  // 2、没有提交的挂起的任务\n  // 3、没有提交的可能被挂起的任务\n  // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能\n  \n  // The earliest and latest priority levels that are suspended from committing.\n  // 提交时候被挂起的最老和最新的任务\n  earliestSuspendedTime: ExpirationTime,\n  latestSuspendedTime: ExpirationTime,\n  \n  // The earliest and latest priority levels that are not known to be suspended.\n  // 在提交时候可能会被挂起的最老和最新的任务（所有任务进来都是这个状态）\n  earliestPendingTime: ExpirationTime,\n  latestPendingTime: ExpirationTime,\n  // The latest priority level that was pinged by a resolved promise and can\n  // be retried.\n  // 最新的通过一个promise被resolve并且可以重新尝试的优先级\n  latestPingedTime: ExpirationTime,\n\n  // 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染\n  // 在`renderRoot`出现无法处理的错误时会被设置为`true`\n  didError: boolean,\n\n\t// 正在等待提交的任务的`expirationTime`\n  pendingCommitExpirationTime: ExpirationTime,\n  // 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null\n  // 在commit阶段只会处理这个值对应的任务\n  finishedWork: Fiber | null,\n  // 在任务被挂起的时候通过setTimeouth函数的返回值\n  // 用来清理下一次如果有新的任务挂起时还没触发的timeout\n  timeoutHandle: TimeoutHandle | NoTimeout,\n  // 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用\n  context: Object | null,\n  pendingContext: Object | null,\n  // 用来确定第一次渲染的时候是否需要融合\n  +hydrate: boolean,\n  // 当前root上剩余的过期时间\n  // TODO: 提到renderer里面区处理\n  nextExpirationTimeToWorkOn: ExpirationTime,\n  // 当前更新对应的过期时间\n  expirationTime: ExpirationTime,\n  // List of top-level batches. This list indicates whether a commit should be\n  // deferred. Also contains completion callbacks.\n  // TODO: Lift this into the renderer\n  // 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟\n  // 同时包括完成之后的回调\n  // 貌似用在测试的时候？\n  firstBatch: Batch | null,\n  // Linked-list of roots\n  // next\n  nextScheduledRoot: FiberRoot | null,\n|};\n")])])]),t("h3",{attrs:{id:"fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fiber","aria-hidden":"true"}},[e._v("#")]),e._v(" Fiber")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber\n{|\n  // Fiber的tag，用来标记不同的组件类型\n  tag: WorkTag,\n\n  // 就是组件的那个key\n  key: null | string,\n\n  // 我们调用`createElement`的第一个参数 div/p/func/class\n  elementType: any,\n\n  // 异步组件resolved之后返回的内容，一般是`function`或者`class`\n  type: any,\n\n  // 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）\n  stateNode: any,\n\n  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回\n  return: Fiber | null,\n\n  // 单链表树结构\n  // 指向自己的第一个子节点\n  child: Fiber | null,\n  // 指向自己的兄弟结构\n  // 兄弟节点的return指向同一个父节点\n  sibling: Fiber | null,\n  index: number,\n\n  // ref\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,\n\n  // 新的变动带来的新的props，就是nextProps\n  pendingProps: any, \n  // 上一次渲染完成之后的propP，就是当前props\n  memoizedProps: any, \n\n  // 该Fiber对应的组件产生的Update会存放在这个队列里面\n  updateQueue: UpdateQueue<any> | null,\n\n  // 上一次渲染的时候的state\n  memoizedState: any,\n\n  // 一个列表，存放这个Fiber依赖的context\n  firstContextDependency: ContextDependency<mixed> | null,\n\n  // 用来描述当前Fiber和他子树的`Bitfield`\n  // 共存的模式表示这个子树是否默认是异步渲染的\n  // Fiber被创建的时候他会继承父Fiber\n  // 其他的标识也可以在创建的时候被设置\n  // 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前\n  mode: TypeOfMode,\n\n  // Effect\n  // 用来记录Side Effect\n  effectTag: SideEffectTag,\n\n  // 单链表用来快速查找下一个side effect\n  nextEffect: Fiber | null,\n\n  // 子树中第一个side effect\n  firstEffect: Fiber | null,\n  // 子树中最后一个side effect\n  lastEffect: Fiber | null,\n\n  // 代表任务在未来的哪个时间点应该被完成\n  // 不包括他的子树产生的任务\n  expirationTime: ExpirationTime,\n\n  // 快速确定子树中是否有不在等待的变化\n  childExpirationTime: ExpirationTime,\n\n  // 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber\n  // 我们称他为`current <==> workInProgress`\n  // 在渲染完成之后他们会交换位置\n  alternate: Fiber | null,\n\n  // 下面是调试相关的，收集每个Fiber和子树渲染时间的\n   \n  actualDuration?: number,\n\n  // If the Fiber is currently active in the "render" phase,\n  // This marks the time at which the work began.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualStartTime?: number,\n\n  // Duration of the most recent render time for this Fiber.\n  // This value is not updated when we bailout for memoization purposes.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  selfBaseDuration?: number,\n\n  // Sum of base times for all descedents of this Fiber.\n  // This value bubbles up during the "complete" phase.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  treeBaseDuration?: number,\n\n  // Conceptual aliases\n  // workInProgress : Fiber ->  alternate The alternate used for reuse happens\n  // to be the same as work in progress.\n  // __DEV__ only\n  _debugID?: number,\n  _debugSource?: Source | null,\n  _debugOwner?: Fiber | null,\n  _debugIsCurrentlyTiming?: boolean,\n|};\n')])])])])},[],!1,null,null,null);n.default=r.exports}}]);