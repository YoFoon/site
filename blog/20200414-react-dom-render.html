<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ReactDOM.render | YoFoon&#39;s前端小站</title>
    <meta name="description" content="好好学习，努力化蛹成蝶">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/logo.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/logo.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="apple-mobile-web-app-status-bar-style">
    
    <link rel="preload" href="/assets/css/0.styles.05cc7eb5.css" as="style"><link rel="preload" href="/assets/js/app.1274b19c.js" as="script"><link rel="preload" href="/assets/js/3.e5f6c01d.js" as="script"><link rel="preload" href="/assets/js/19.081301d7.js" as="script"><link rel="preload" href="/assets/js/6.da654ace.js" as="script"><link rel="prefetch" href="/assets/js/10.92e21c8d.js"><link rel="prefetch" href="/assets/js/11.cc1411d8.js"><link rel="prefetch" href="/assets/js/12.2d961c16.js"><link rel="prefetch" href="/assets/js/13.205676dc.js"><link rel="prefetch" href="/assets/js/14.b165508a.js"><link rel="prefetch" href="/assets/js/15.486ed8f4.js"><link rel="prefetch" href="/assets/js/16.ac82d50a.js"><link rel="prefetch" href="/assets/js/17.db1abd0b.js"><link rel="prefetch" href="/assets/js/18.bd9497b5.js"><link rel="prefetch" href="/assets/js/20.b8d7b737.js"><link rel="prefetch" href="/assets/js/21.086584d3.js"><link rel="prefetch" href="/assets/js/22.70d87ff4.js"><link rel="prefetch" href="/assets/js/23.cf08daab.js"><link rel="prefetch" href="/assets/js/24.07387fb5.js"><link rel="prefetch" href="/assets/js/25.4e770138.js"><link rel="prefetch" href="/assets/js/26.4bf8b93c.js"><link rel="prefetch" href="/assets/js/27.38076681.js"><link rel="prefetch" href="/assets/js/28.eddd4fec.js"><link rel="prefetch" href="/assets/js/29.10d1433e.js"><link rel="prefetch" href="/assets/js/30.4a707e0a.js"><link rel="prefetch" href="/assets/js/31.8677c398.js"><link rel="prefetch" href="/assets/js/32.12c7f3b9.js"><link rel="prefetch" href="/assets/js/33.932ee82b.js"><link rel="prefetch" href="/assets/js/34.d4b9aeb4.js"><link rel="prefetch" href="/assets/js/35.acc1896e.js"><link rel="prefetch" href="/assets/js/36.527e7284.js"><link rel="prefetch" href="/assets/js/37.a3f87927.js"><link rel="prefetch" href="/assets/js/38.88ddbf7a.js"><link rel="prefetch" href="/assets/js/39.fd7962a1.js"><link rel="prefetch" href="/assets/js/4.d584cd42.js"><link rel="prefetch" href="/assets/js/40.15dc2bae.js"><link rel="prefetch" href="/assets/js/41.92269fcd.js"><link rel="prefetch" href="/assets/js/42.b6a87d96.js"><link rel="prefetch" href="/assets/js/43.84bcdfb9.js"><link rel="prefetch" href="/assets/js/44.86791ad1.js"><link rel="prefetch" href="/assets/js/45.6a3fb16d.js"><link rel="prefetch" href="/assets/js/46.b5293326.js"><link rel="prefetch" href="/assets/js/47.7d80c117.js"><link rel="prefetch" href="/assets/js/48.5085aee1.js"><link rel="prefetch" href="/assets/js/49.45b201a6.js"><link rel="prefetch" href="/assets/js/5.e3a314f7.js"><link rel="prefetch" href="/assets/js/50.3ea3c47a.js"><link rel="prefetch" href="/assets/js/51.7319689a.js"><link rel="prefetch" href="/assets/js/52.c4d9b204.js"><link rel="prefetch" href="/assets/js/53.3114bf6b.js"><link rel="prefetch" href="/assets/js/54.995bca0e.js"><link rel="prefetch" href="/assets/js/55.e27397eb.js"><link rel="prefetch" href="/assets/js/56.e4513a4e.js"><link rel="prefetch" href="/assets/js/57.1159b507.js"><link rel="prefetch" href="/assets/js/58.7d58a545.js"><link rel="prefetch" href="/assets/js/59.dbd46eb1.js"><link rel="prefetch" href="/assets/js/60.92e88ec9.js"><link rel="prefetch" href="/assets/js/61.8d5cdca3.js"><link rel="prefetch" href="/assets/js/62.9af7431d.js"><link rel="prefetch" href="/assets/js/63.b41e9a05.js"><link rel="prefetch" href="/assets/js/64.4a3c4ea7.js"><link rel="prefetch" href="/assets/js/65.835613ef.js"><link rel="prefetch" href="/assets/js/66.8cd25ac9.js"><link rel="prefetch" href="/assets/js/67.2fdfc8d2.js"><link rel="prefetch" href="/assets/js/68.1a6fa670.js"><link rel="prefetch" href="/assets/js/69.24c523fc.js"><link rel="prefetch" href="/assets/js/7.0f973c56.js"><link rel="prefetch" href="/assets/js/70.afc49943.js"><link rel="prefetch" href="/assets/js/71.425d9845.js"><link rel="prefetch" href="/assets/js/72.df82cb35.js"><link rel="prefetch" href="/assets/js/73.6461ff8b.js"><link rel="prefetch" href="/assets/js/74.42fdc9ca.js"><link rel="prefetch" href="/assets/js/75.6029d9dd.js"><link rel="prefetch" href="/assets/js/76.ac5c877d.js"><link rel="prefetch" href="/assets/js/77.91697145.js"><link rel="prefetch" href="/assets/js/78.3f23eaf7.js"><link rel="prefetch" href="/assets/js/79.3390703e.js"><link rel="prefetch" href="/assets/js/8.cd0d92c8.js"><link rel="prefetch" href="/assets/js/80.14cf59a6.js"><link rel="prefetch" href="/assets/js/81.df106301.js"><link rel="prefetch" href="/assets/js/82.b9c47d41.js"><link rel="prefetch" href="/assets/js/83.7d601b24.js"><link rel="prefetch" href="/assets/js/84.8f06dfd5.js"><link rel="prefetch" href="/assets/js/85.0361ac05.js"><link rel="prefetch" href="/assets/js/86.cfc2ea02.js"><link rel="prefetch" href="/assets/js/87.04b875f6.js"><link rel="prefetch" href="/assets/js/9.cd570fc8.js"><link rel="prefetch" href="/assets/js/vendors~notification.7bcb2342.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05cc7eb5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YoFoon's前端小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knowledge/" class="nav-link">知识</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div> <a href="https://github.com/YoFoon/FE-FACE" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knowledge/" class="nav-link">知识</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div> <a href="https://github.com/YoFoon/FE-FACE" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>博客</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" class="sidebar-link">快速链接链接</a></li><li><a href="/blog/20200414-hide-element.html" class="sidebar-link">点击空白处隐藏弹出元素</a></li><li><a href="/blog/20200414-intersection-observer.html" class="sidebar-link">IntersectionObserver 懒加载</a></li><li><a href="/blog/20200414-shell-push-git.html" class="sidebar-link">shell 推送 git</a></li><li><a href="/blog/20200421-wang-editor-add-upload-file.html" class="sidebar-link">wangEditor 上传附件</a></li><li><a href="/blog/20200422-ye-mian-zhu-ru-50-wan-ge-li.html" class="sidebar-link">页面注入50万个li怎么做提升性能？</a></li><li><a href="/blog/20200424-qian-duan-gong-cheng-hua.html" class="sidebar-link">前端工程化</a></li><li><a href="/blog/20200430-ArrayBuffer-Blob-File.html" class="sidebar-link">ArrayBuffer,Blob,FileReader 三大对象</a></li><li><a href="/blog/20200914-tong-guo-localStorage-tong-yuan-fa-song-xin-xi.html" class="sidebar-link">通过localStorage同域发送信息</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>大数据处理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/20200428-BitMap.html" class="sidebar-link">BitMap 算法</a></li><li><a href="/blog/20200509-node-big-text.html" class="sidebar-link">NODE 大文件读写</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/20200414-jsx-2-virtual-dom.html" class="sidebar-link">从 jsx 到 virtual dom</a></li><li><a href="/blog/20200414-react-data-struct.html" class="sidebar-link">React中的数据结构</a></li><li><a href="/blog/20200414-react-dom-render.html" class="active sidebar-link">ReactDOM.render</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/20200414-react-dom-render.html#reactdom-render" class="sidebar-link">ReactDOM.render</a></li></ul></li><li><a href="/blog/20200414-expiration-time.html" class="sidebar-link">ExpirationTime 计算规则</a></li><li><a href="/blog/20200414-enqueue-update.html" class="sidebar-link">enqueueUpdate</a></li><li><a href="/blog/20200414-schedule-work.html" class="sidebar-link">调度入口函数 scheduleWork</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="reactdom-render"><a href="#reactdom-render" aria-hidden="true" class="header-anchor">#</a> ReactDOM.render</h2> <p>上文说的是把 jsx 转换成 VDom</p> <p>而 ReactDom.render 则是把 VDom 渲染成真实的 Dom 节点（本篇幅只涉及到渲染，没有涉及到更新、调度等等）</p> <p>我们在写 react 的时候，写到最后一步肯定是 ReactDom.render，比如</p> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.render(&lt;App name='app' /&gt;, document.getElementById('app'));
</code></pre></div><p>把<code>&lt;App /&gt;</code>解析成 Vdom</p> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.render(React.createElement(App, {
  name: &quot;app&quot;
}), document.getElementById('app'));
</code></pre></div><p>终于撸到 render 了呀，找到<code>react-dom</code>库里面的<code>ReactDom.js</code></p> <div class="language- extra-class"><pre class="language-text"><code>const ReactDOM: Object = {

  ...

  render(
    element: React$Element&lt;any&gt;, // ReactElement
    container: DOMContainer, // 页面上挂载的dom节点
    callback: ?Function, // callback 渲染完成后的回调，一般不使用
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  }

  ...

};
</code></pre></div><p>我们看到 ReactDom.render 传入了 Vdom，挂载的 dom 节点，还有一个回调函数，终于返回了一个<code>legacyRenderSubtreeIntoContainer</code>,直译这个函数可能大概是：<strong>渲染子树给容器</strong>，这个函数，实际上就是初始化了<code>root</code>，并且调用了<code>root.render</code>方法，而<code>root</code>是由<code>legacyCreateRootFromDOMContainer</code>返回的</p> <div class="language- extra-class"><pre class="language-text"><code>function legacyRenderSubtreeIntoContainer(
	// 父组件，React.Dom传入的为null
  parentComponent: ?React$Component&lt;any, any&gt;,
  // 子组件，就是React.Dom中传入的组件
  children: ReactNodeList,
  // 容器，挂载子组件的节点
  container: DOMContainer,
  // 用来判断是否为服务端渲染。hydrate和render唯一的区别就这个值。服务端渲染用了hydrate而不是render
  // render 中的值就是false
  forceHydrate: boolean,
  // 渲染完成后的回调
  callback: ?Function,
) {
  // 对容易进行检测，是否为一个真实的dom节点，确保容器可挂载
  invariant(
    isValidContainer(container),
    'Target container is not a DOM element.',
  );

  if (__DEV__) {
    ...
  }

	// 取root对象，一般如果非服务器端渲染这个root是不存在的
  let root: Root = (container._reactRootContainer: any);
  if (!root) {
  	// 初始化root和container._reactRootContainer，创建一个HostRoot对象，是Fiber对象的一种
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );

    if (typeof callback === 'function') {
      ...
    }
    // Initial mount should not be batched.
    // DOMRenderer.unbatchedUpdates不使用batchedUpdates，因为这是初次渲染，需要尽快完成
    DOMRenderer.unbatchedUpdates(() =&gt; {
      if (parentComponent != null) {
        // 向真实dom中挂载虚拟dom
        root.legacy_renderSubtreeIntoContainer(
          parentComponent,
          children,
          callback,
        );
      } else {
      	// 直接render
        root.render(children, callback);
      }
    });
  } else {
  	// 此处涉及到更新这一块
    ...
  }
  // 返回container 中的dom
  return DOMRenderer.getPublicRootInstance(root._internalRoot);
}
</code></pre></div><p>然后我们来看一下我们是如何初始化 root，创建一个 Fiber 对象的</p> <div class="language- extra-class"><pre class="language-text"><code>function legacyCreateRootFromDOMContainer(
  container: DOMContainer, // 这个传进来的是挂载子组件的节点，dom根节点
  forceHydrate: boolean,
): Root {
	// 是否服务端渲染 或者 判断dom节点是否已经被挂载
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    // 清空挂载dom根节点
    while ((rootSibling = container.lastChild)) {
      if (__DEV__) {
        ...
      }
      container.removeChild(rootSibling);
    }
  }
  if (__DEV__) {
    ...
  }
  // Legacy roots are not async by default.
  // 默认为同步状态
  const isConcurrent = false;
  return new ReactRoot(container, isConcurrent, shouldHydrate);
}
</code></pre></div><p>我们发现<code>legacyCreateRootFromDOMContainer</code>实际上做的只是在非 ssr 的情况下，将 dom 根节点清空，然后返回一个<code>new ReactRoot</code>，这里需要注意一点， root 默认是同步更新的， 即<strong>isConcurrent</strong> 默认为 false</p> <p>那么重点就跑到了<code>ReactRoot</code>中</p> <div class="language- extra-class"><pre class="language-text"><code>function ReactRoot(
  container: Container,// 这个传进来的是挂载子组件的节点，dom根节点
  isConcurrent: boolean,  //root默认是同步更新的， isConcurrent 为false
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}
</code></pre></div><p>从<code>ReactRoot</code>中， 我们把<code>createContainer</code>返回值赋给了 实例的<code>_internalRoot</code>， 往下看<code>createContainer</code></p> <p><code>createContainer</code>这个函数不在<code>ReactDOM.js</code>中，找到<code>ReactFiberReconciler.js</code>,打开它，并找到</p> <div class="language- extra-class"><pre class="language-text"><code>function createContainer(
  containerInfo: Container, // 这个传进来的是挂载子组件的节点，dom根节点
  isConcurrent: boolean, //root默认是同步更新的， isConcurrent 为false
  hydrate: boolean,
): OpaqueRoot {
  return createFiberRoot(containerInfo, isConcurrent, hydrate);
}
</code></pre></div><p>从<code>createContainer</code>看出， <code>createContainer</code>实际上是直接返回了<code>createFiberRoot</code>,</p> <div class="language- extra-class"><pre class="language-text"><code>function createFiberRoot(
  containerInfo: any, // 这个传进来的是挂载子组件的节点，dom根节点
  isConcurrent: boolean, //root默认是同步更新的， isConcurrent 为false
  hydrate: boolean,
): FiberRoot {
	// 创建FiberRoot
  const uninitializedFiber = createHostRootFiber(isConcurrent);

  let root;
  // 对root赋值,详情在 React中的数据结构中 有
  if (enableSchedulerTracing) {
    root = ({
    	current: uninitializedFiber
      ...
    }: FiberRoot);
  } else {
    root = ({
    	current: uninitializedFiber
      ...
    }: BaseFiberRootProperties);
  }

  uninitializedFiber.stateNode = root;
  return ((root: any): FiberRoot);
}
</code></pre></div><p>而<code>createFiberRoot</code>则是通过<code>createHostRootFiber</code>函数的返回值<code>uninitializedFiber</code>，并将其赋值在<code>root</code>对象的<code>current</code>上， 这里需要注意一个点就是，<code>uninitializedFiber</code>的<code>stateNode</code>的值是<code>root</code>， 即他们互相引用
最后<code>createFiberRoot</code>返回了一个<code>fiberNode</code>的实例</p> <p>我们来整理一下<code>createFiberRoot</code>中各个实力的关系</p> <div class="language- extra-class"><pre class="language-text"><code> root为ReactRoot实例，
 root._internalRoot 即为fiberRoot实例，
 root._internalRoot.current即为Fiber实例，
 root._internalRoot.current.stateNode = root._internalRoot
</code></pre></div><p>接下来我们看一下<code>uninitializedFiber</code>是什么，是怎么创建的</p> <div class="language- extra-class"><pre class="language-text"><code>createHostRootFiber(isConcurrent: boolean): Fiber { //root默认是同步更新的，isConcurrent为false
	// NoContext 的值为 0b000， 由于在一开始就将isAsync初始化为false， 所以mode实际上就代表了同步
  let mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

  // devtools时收集配置文件计时,使得devtools可以在任何点开始捕获时间
  if (enableProfilerTimer &amp;&amp; isDevToolsPresent) {
    mode |= ProfileMode;
  }
	// HostRoot = 3; // 是一棵树的顶级节点。但是可以存在兄弟节点
  return createFiber(HostRoot, null, null, mode);
}

const createFiber = function(
  tag: WorkTag, // 就是HostRoot = 3; // 是一棵树的顶级节点。
  pendingProps: mixed, // 新的变动带来的新的props
  key: null | string, // 就是react中用到的那个key
  mode: TypeOfMode, // 同步的还是异步的。上面传入的是false，表示同步
): Fiber {
	// 返回了一个Fiber节点
  return new FiberNode(tag, pendingProps, key, mode);
};
</code></pre></div><p><code>FiberNode</code>这个节点在文末具体讲解。到这里为止初始化<code>FiberRoot</code>已经完毕，接下来就要开始挂载节点了，挂载节点我们就要返回到上文提到的<code>legacyRenderSubtreeIntoContainer</code>,接着这个函数中<code>legacyCreateRootFromDOMContainer</code>的执行顺序，往下执行就是<code>DOMRenderer.unbatchedUpdates</code>，执行并传入一个回调函数，在<code>ReactFiberSchedule</code>中找到这个这个函数</p> <div class="language- extra-class"><pre class="language-text"><code>// 这里顺手贴上这两个变量的初始值
let isBatchingUpdates: boolean = false; // 正在批量更新的标识
let isUnbatchingUpdates: boolean = false; // 未批量更新的标识

// 非批量更新   fn 就是传入的回调的函数
function unbatchedUpdates&lt;A, R&gt;(fn: (a: A) =&gt; R, a: A): R {
	// 正在批量更新
  if (isBatchingUpdates &amp;&amp; !isUnbatchingUpdates) {
    isUnbatchingUpdates = true;
    try {
    	// 将为未批量更新设置为true，运行fn，并返回
      return fn(a);
    } finally {
    	// 重置
      isUnbatchingUpdates = false;
    }
  }
  // 没有正在批量更新，运行fn，并返回。
  return fn(a);
}
</code></pre></div><p><code>unbatchedUpdates</code>中执行完之后，无论怎么判断，都走到了 <code>root.legacy_renderSubtreeIntoContainer</code> 和 <code>root.render</code>。以为本章不涉及调度更新，所以只讲<code>root.render</code></p> <div class="language- extra-class"><pre class="language-text"><code>// root 是通过 ReactRoot new 出来的
ReactRoot.prototype.render = function(
  children: ReactNodeList, // 子组件，就是React.Dom中传入的组件
  callback: ?() =&gt; mixed, // 渲染完成后的回调
): Work {
	// 在 ReactRoot 这个构造函数中，_internalRoot = root, 就是fiberRoot实例
  const root = this._internalRoot;

  const work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (__DEV__) {
    ...
  }
  if (callback !== null) {
    work.then(callback);
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit);
  return work;
};
</code></pre></div><p>解释与一下<code>ReactWork</code>,这是一个很简单的东西，它有两个值<code>callbacks</code>和<code>didCommit</code>。通过执行<code>then</code>函数传入<code>callback</code>，如果判断到当前的<code>didCommit</code>为<code>false</code>的情况下，就将<code>callback</code>添加到<code>callbacks</code>数组内。然后通过执行<code>onCommit</code>去改变<code>didCommit</code>的值，之后循环执行<code>_callbacks</code>中的<code>callback</code>。在这里，我们就把<code>work._onCommit</code>当成一个回调函数就好了。</p> <p>接下来，我们看到<code>root</code>即<code>FiberRoot</code>实例被当成函数传入了<code>updateContsainer</code>,在<code>ReactFiberSchedule.js</code>中找到这个这个函数</p> <div class="language- extra-class"><pre class="language-text"><code>function updateContainer(
  element: ReactNodeList, // 子组件，就是React.Dom中传入的组件
  container: OpaqueRoot, // FiberRoot, 顶级root节点
  parentComponent: ?React$Component&lt;any, any&gt;, // null
  callback: ?Function, // callback
): ExpirationTime {
	// container的current 就是container对应的Fiber，就是FiberRoot
  const current = container.current;
  // currentTime是用来计算expirationTime
  const currentTime = requestCurrentTime();
  // expirationTime代表着优先级，expirationTime越小，优先级越高
  // 同步模式下该值为 1， 每个层级的任务都是以链表的形式存在
  // expirationTime 顾名思义就是这次更新的 超时时间, 留在后续分析
  const expirationTime = computeExpirationForFiber(currentTime, current);

  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  );
}
</code></pre></div><p>往下继续查看<code>updateContainerAtExpirationTime</code></p> <div class="language- extra-class"><pre class="language-text"><code>function updateContainerAtExpirationTime(
  element: ReactNodeList, // 子组件，就是React.Dom中传入的组件
  container: OpaqueRoot, // FiberRoot, 顶级root节点
  parentComponent: ?React$Component&lt;any, any&gt;, // null
  expirationTime: ExpirationTime, // 超时时间
  callback: ?Function, // callback
) {
  // container的current 就是container对应的Fiber，就是FiberRoot
  const current = container.current;

  if (__DEV__) {
    ...
  }

	// parentComponent 为null，所以得到context为一个空对象 {}
  const context = getContextForSubtree(parentComponent);
  // container.context 为null
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

	// 开始调度
  return scheduleRootUpdate(current, element, expirationTime, callback);
}
</code></pre></div><p>接下来继续查看<code>scheduleRootUpdate</code></p> <div class="language- extra-class"><pre class="language-text"><code>function scheduleRootUpdate(
  current: Fiber, // current 就是container对应的Fiber，就是FiberRoot
  element: ReactNodeList, // 子组件，就是React.Dom中传入的组件
  expirationTime: ExpirationTime, // 超时时间
  callback: ?Function, // callback
) {
  if (__DEV__) {
    ...
  }
	// 使用 createUpdate 创建 update 来标记 react 需要更新的点
  const update = createUpdate(expirationTime);
  // payload 就是setState中传入的对象，因为这里是更新组件，所以把整个子组件放进去更新
  update.payload = {element};

  if (callback !== null) {
    ...
  }
  // enqueueUpdate 把 update 放入更新队列里 react 更新会在一个节点上整体进行很多个更新
  // 这个更新 queue 就是管理多次更新的作用
  enqueueUpdate(current, update);

	// 最后执行 scheduleWork 通知 react 进行调度，根据任务的优先级进行更新。
  scheduleWork(current, expirationTime);
  return expirationTime;
}
</code></pre></div><p>我们本章节的内容就到这里了</p> <p>####来总结一下吧</p> <ul><li><p>初次渲染 传入 APP 组件和<code>getElementById(app)</code>执行 <code>ReactDOM.render</code></p></li> <li><p><code>ReactDOM.render</code>返回并执行<code>legacyRenderSubtreeIntoContainer</code></p> <ul><li><code>legacyRenderSubtreeIntoContainer</code>内调用<code>legacyCreateRootFromDOMContainer</code>把返回值挂载到 <code>root</code>节点的<code>_reactRootContainer</code> 属性上</li> <li>而 <code>legacyCreateRootFromDOMContainer</code> 把 <code>getElementById(root)</code> 里的子节点清空，创建并返回 <code>new ReactRoot</code> 给 <code>getElementById(root)</code>的<code>_reactRootContainer</code> 属性上</li> <li><code>ReactRoot</code>生成实例时调用<code>react-reconcile</code>模块的<code>createContainer</code> 传入 ge<code>tElementById(root)</code>执行<code>createFiberRoot</code> 生成一个<code>FiberRoot</code> 对象挂载到实例的 <code>_internalRoot</code></li></ul></li> <li><p><code>legacyRenderSubtreeIntoContainer</code>最终调用 上面生成的 <code>ReactRoot</code>实例的 <code>ReactRoot.prototype.render</code>原型方法</p> <ul><li><p><code>ReactRoot.prototype.render</code> 把子节点和实例生成的 <code>_internalRoot Fiber</code> 对象传入 <code>react-reconcile</code> 模块的<code>updateContainer</code> 中</p> <ul><li><p>在<code>updateContainer</code> 中 计算出一个 <code>expirationTime</code> 传入 <code>updateContainerAtExpirationTime</code> 调用 <code>scheduleRootUpdate</code> 中做三件事</p> <blockquote><p>1、使用<code>createUpdate</code> 创建 update 来标记 react 需要更新的点</p> <p>2、设置完 update 属性再调用<code>enqueueUpdate</code>把 update 放入当前节点树整体的更新队列里</p> <p>3、最后执行<code>scheduleWork</code>通知 react 进行调度，根据任务的优先级进行更新</p></blockquote></li></ul></li></ul></li> <li><p><code>ReactDOM.render</code>此时</p> <ul><li>创建了一个 <code>ReactRoot</code> 对象挂载到 <code>getElementById(root)</code> 的<code>_reactRootContainer</code> 属性上</li> <li>同时 在<code>ReactRoot</code> 实例 <code>_internalRoot</code>属性上生成了 <code>Fiber</code>对象</li> <li>调用 <code>ReactRoot.prototype.render</code> 执行<code>react-reconcile</code> 模块的<code>updateContainer</code>计算 <code>expirationTime</code>，通过 <code>expirationTime</code> 来创建<code>update</code>对象，推入 <code>updateQueue</code> 内，最后根据优先级进行调度。</li></ul></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/YoFoon/FE-FACE/edit/master/blog/20200414-react-dom-render.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/20200414-react-data-struct.html" class="prev">
          React中的数据结构
        </a></span> <span class="next"><a href="/blog/20200414-expiration-time.html">
          ExpirationTime 计算规则
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.1274b19c.js" defer></script><script src="/assets/js/3.e5f6c01d.js" defer></script><script src="/assets/js/19.081301d7.js" defer></script><script src="/assets/js/6.da654ace.js" defer></script>
  </body>
</html>
